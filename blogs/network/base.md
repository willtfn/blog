---
title: 计算机网络基础
date: 2021-08-14
tags:
  - 读书笔记
  - 计算机网络
  - DNS
  - HTTP
  - TCP/IP
categories:
  - 计算机网络
---

## 基础知识

### 网络类型

#### 按网络的作用范围进行分类

1. 广域网 WAN (Wide Area Network) ，作用范围通常为几十到几千公里
2. 城域网 MAN (Metropolitan Area Network) ，作用范围一般是一个城市，可跨越几个街区甚至整个的城市，其作用距离约为 5 ～ 50km。
3. 局域网 LAN (Local Area Network)，一般用微型计算机或工作站通过高速通信线路相连（速率通常在 10Mb/s 以上），但地理上则局限在较小的范围（如 1km 左右）。比如学习、企业等内部网络。
4. 个人区域网 PAN (Personal Area Network)，就是在个人工作的地方把属于个人使用的电子设备（如便携式电脑等）用无线技术连接起来的网络，因此也常称为无线个人区域网 WPAN(Wireless PAN)，其范围大约在 10 m 左右。

#### 按网络使用者分类

1. 公用网(public network)，是指电信公司（国有或私有）出资建造的大型网络。普通民众交纳一定的费用就可以使用。
2. 专用网(private network)，是某个部门、某个行业为各自的特殊业务工作需要而建造的网络。比如军队、银行、铁路等系统，不对外人提供服务。

### 数据量单位

比特（bit）是计算机中数据量的单位，一个比特就是二进制数字中的一个 1 或 0。一般记为小写 b。

速率是计算机网络中最重要的一个性能指标。速率的单位是 b/s（比特每秒）(或 bit/s，有时也写为 bps，即 bit per second)。当数据率较高时，就可以用 kb/s（k = 10^3^ =千）、Mb/s（M = 10^6^ = 兆）、Gb/s（G = 10^9^ = 吉）或 Tb/s（T = 10^12^ = 太）。

计算机中的数据量往往用**字节**作为度量的单位，一个字节(byte，记为大写的 B)代表 8 个比特，即 1B = 8b = 2^3^ b。同样也存在千字节 KB、兆字节 MB、吉字节 GB 等等。

::: warning
在通信领域，小写的 k 表示 10^3^=1000，大写的 K 表示 2^10^=1024。

1Gb/s = 10^3^Mb/s = 10^6^kb/s = 10^9^b/s

1GB = 2^10^MB = 2^20^KB = 2^30^B = 2^30^ x 2^3^b
:::

## 计算机网络体系结构

OSI 的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用。而 TCP/IP 的四层体系结构已经得到了非常广泛的应用。为了方便学习，采用折中的方法，综合 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构。如下图所示：

<p>
   <img src="./images/base_jiegou_1.png" style="max-width: 80%;" class="medium-zoom-image"/>
</p>

1. 应用层

   应用层的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信和交互的规则。在因特网中的应用层协议很多，如支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议，支持文件传送的 FTP 协议，等等。

2. 运输层

   运输层的任务就是负责向两个主机中进程之间的通信提供通用的数据传输服务。运输层主要使用以下两种协议：

   - 传输控制协议 TCP (Transmission ControlProtocol)——提供面向连接的、可靠的数据传输服务，其数据传输的单位是报文段(segment)。
   - 用户数据报协议 UDP (User DatagramProtocol)——提供无连接的、尽最大努力(best-effort)的数据传输服务（不保证数据传输的可靠性），其数据传输的单位是用户数据报。

3. 网络层

   网络层负责为分组交换网上的不同主机提供通信服务。在 TCP/IP 体系中，由于网络层使用 IP 协议，因此分组也叫作 IP 数据报。网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够通过网络中的路由器找到目的主机。

4. 数据链路层

   在两个相邻结点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧（framing），在两个相邻结点间的链路上传送帧（frame）。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制等）。数据链路层在收到一个帧后，就可从中提取出数据部分，上交给网络层。

5. 物理层

   在物理层上所传数据的单位是比特，即 1 或 0。因此物理层要考虑用多大的电压代表“1”或“0”，以及接收方如何识别出发送方所发送的比特，等等。

**数据在各层之间的传递过程如图所示：**

<p>
   <img src="./images/base_jiegou_2.png" style="max-width: 80%;" class="medium-zoom-image"/>
</p>

## 物理层

物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。可以将物理层的主要任务描述为确定与传输媒体的接口有关的一些特性，即：

1. **机械特性** 指明接口所用接线器的形状和尺寸，引脚数目和排列，固定和锁定装置，等等。平时常见的各种规格的接插件都有严格的标准化的规定。

2. **电气特性** 指明在接口电缆的各条线上出现的电压的范围。

3. **功能特性** 指明某条线上出现的某一电平的电压表示何种意义。

4. **过程特性** 指明对于不同功能的各种可能事件的出现顺序。

## 数据链路层

链路是从一个结点到相邻结点的一段物理线路，数据链路则是在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）。

数据链路层使用的信道主要有以下两种类型：

1. **点对点信道**。这种信道使用一对一的点对点通信方式。
2. **广播信道**。这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。

点对点协议 PPP 是数据链路层使用的最多的一种协议。

### 点对点信道

<p>
   <img src="./images/base_lianlu_1.png" style="max-width: 80%;" class="medium-zoom-image"/>
</p>

点对点信道的数据链路层在进行通信时的主要步骤如下：

1. 结点 A 的数据链路层把网络层交下来的 IP 数据报添加首部和尾部封装成帧。

2. 结点 A 把封装好的帧发送给结点 B 的数据链路层。

3. 若结点 B 的数据链路层收到的帧无差错，则从收到的帧中提取出 IP 数据报上交给上面的网络层；否则丢弃这个帧。

## 网络层

TCP/IP 体系中的网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限，所传送的分组可能出错、丢失、重复和失序。进程之间的通信的可靠性由运输层负责。

### 网际协议 IP

网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一，也是最重要的因特网标准协议之一。与 IP 协议配套使用的还有三个协议：

- 地址解析协议 ARP (Address ResolutionProtocol)
- 网际控制报文协议 ICMP (Internet ControlMessage Protocol)
- 网际组管理协议 IGMP (Internet GroupManagement Protocol)

整个的因特网就是一个单一的、抽象的网络。IP 地址就是给因特网上的每一个主机（或路由器）的每一个接口分配一个在全世界范围是唯一的 32 位的标识符。IP 地址的编址方法共经过了三个历史阶段：

1. 分类的 IP 地址。
2. 子网的划分。
3. 构成超网。

### 分类的 IP 地址

所谓“分类的 IP 地址”就是将 IP 地址划分为若干个固定类，每一类地址都由两个固定长度的字段组成，其中第一个字段是网络号(net-id)，它标志主机（或路由器）所连接到的网络。一个网络号在整个因特网范围内必须是唯一的。第二个字段是主机号(host-id)，它标志该主机（或路由器）。一个主机号在它前面的网络号所指明的网络范围内必须是唯一的。由此可见，一个 IP 地址在整个因特网范围内是唯一的。

<p>
   <img src="./images/base_wangluo_ip.png" style="max-width: 60%;" class="medium-zoom-image"/>
</p>

从 IP 地址的结构来看，IP 地址并不仅仅指明一个主机，而是还指明了主机所连接到的网络。

IP 地址点分十进制的记法：

<p>
   <img src="./images/base_wangluo_ip2.png" style="max-width: 60%;" class="medium-zoom-image"/>
</p>

### 划分子网

划分子网的方法是从网络的主机号借用若干位作为子网号 subnet-id，当然主机号也就相应减少了同样的位数。于是两级 IP 地址在本单位内部就变为三级 IP 地址：**网络号**、**子网号**和**主机号**。凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号找到连接在本单位网络上的路由器。但此路由器在收到 IP 数据报后，再按目的网络号和子网号找到目的子网，把 IP 数据报交付目的主机。

<p>
   <img src="./images/base_wangluo_ip5.png" style="max-width: 60%;" class="medium-zoom-image"/>
</p>

如图所示：

一个 B 类 IP 地址，网络地址是 145.13.0.0（网络号是 145.13）。凡目的地址为 145.13.x.x 的数据报都被送到这个网络上的路由器 R~1~。假定子网号占用 8 位，因此在增加了子网号后，主机号就只有 8 位。所划分的三个子网分别是：145.13.3.0，145.13.7.0 和 145.13.21.0。在划分子网后，整个网络对外部仍表现为一个网络，其网络地址仍为 145.13.0.0。但网络 145.13.0.0 上的路由器 R~1~ 在收到外来的数据报后，再根据数据报的目的地址把它转发到相应的子网。

那么，如何区分一个 IP 地址是二级结构？还是三级子网机构？答案是使用**子网掩码**。

### IP 地址与硬件地址

硬件地址也称为物理地址，物理地址是数据链路层和物理层使用的地址，而 IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。

在发送数据时，数据从高层下到低层，然后才到通信链路上传输。使用 IP 地址的 IP 数据报一旦交给了数据链路层，就被封装成 MAC 帧了。MAC 帧在传送时使用的源地址和目的地址都是硬件地址，这两个硬件地址都写在 MAC 帧的首部中。

<p>
   <img src="./images/base_wangluo_ip3.png" style="max-width: 60%;" class="medium-zoom-image"/>
</p>

IP 地址放在 IP 数据报的首部，而硬件地址则放在 MAC 帧的首部。在网络层和网络层以上使用的是 IP 地址，而数据链路层及以下使用的是硬件地址。

### IP 数据报的格式

在 TCP/IP 的标准中，各种数据格式常常以 32 位(即 4 字节)为单位来描述。下图是 IP 数据报的完整格式。

<p>
   <img src="./images/base_wangluo_ip4.png" style="max-width: 60%;" class="medium-zoom-image"/>
</p>

IP 数据报分为首部和数据两部分。首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的（源地址、目的地址、总长度等重要字段都在固定首部中）。一些长度可变的可选字段放在固定首部的后面。

详细说明参考《计算机网络》（第 6 版 谢希仁 ）的 4.2.5 章节。

## 运输层

运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。

IP 协议能够把源主机 A 发送出的分组按照首部中的目的地址送交到目的主机 B，那么，为什么还需要运输层呢？

从 IP 层来说，通信的两端是两个主机。IP 数据报的首部明确地标志了这两个主机的 IP 地址。但“两个主机之间的通信”这种说法还不够清楚。这是因为，真正进行通信的实体是在主机中的进程，是这个主机中的一个进程和另一个主机中的一个进程在交换数据（即通信）。因此严格地讲，两个主机进行通信就是两个主机中的应用进程互相通信。IP 协议虽然能把分组送到目的主机，但是这个分组还停留在主机的网络层而没有交付主机中的应用进程。从运输层的角度看，**通信的真正端点并不是主机而是主机中的进程**。

**网络层是为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。**

TCP/IP 运输层的两个主要协议都是因特网的正式标准，即：

1. 用户数据报协议 UDP (User Datagram Protocol)
2. 传输控制协议 TCP (Transmission Control Protocol)

<p>
   <img src="./images/base_yunshu_1.png" style="max-width: 180px;" class="medium-zoom-image"/>
</p>

通俗的讲，UDP 就像发短信，不需要事先拨通对方电话，不需要关注对方网络状态，只管自己发出短信。TCP 就像打电话，要先拨通对方电话，才能开始沟通。

使用 UDP 和 TCP 协议的各种应用和应用层协议：

<p>
   <img src="./images/base_yunshu_2.png" style="max-width: 500px;" class="medium-zoom-image"/>
</p>

### UDP

1. UDP 是**无连接的**，即发送数据之前不需要建立连接（当然，发送数据结束时也没有连接可释放），因此减少了开销和发送数据之前的时延。
2. UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。
3. UDP 是面向报文的。对应用层交下来的报文，既不合并，也不拆分，应用层交给 UDP 多长的报文，UDP 就照样发送。
4. UDP 没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。
5. UDP 支持一对一、一对多、多对一和多对多的交互通信。
6. UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。

### TCP

1. TCP 提供**面向连接的服务**。在传送数据之前必须先建立连接，数据传送结束后要释放连接。
2. 每一条 TCP 连接只能有两个端点(endpoint)，每一条 TCP 连接只能是点对点的（一对一）。TCP 不提供广播或多播服务。
3. TCP 提供可靠交付的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复、并且按序到达。
4. TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。
5. 面向字节流。虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据看成仅仅是一连串的无结构的字节流。

由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等。

TCP 连接的端点叫做套接字(socket)或插口，`套接字 socket = （IP 地址:端口号）`，即套接字的表示方法是在点分十进制的 IP 地址后面写上端口号，中间用冒号或逗号隔开。比如，192.3.4.5:80。

同一个 IP 地址可以有多个不同的 TCP 连接，而同一个端口号也可以出现在多个不同的 TCP 连接中。

#### 可靠传输的工作原理

1. 停止等待协议

   “停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。

   <p>
      <img src="./images/base_yunshu_3.png" style="max-width: 60%;" class="medium-zoom-image"/>
   </p>

   无差错的情况下，一切安好。出错的情况下，作为接收方 B，接收 M~1~ 时检测出了差错，就丢弃 M~1~，其他什么也不做。作为发送方 A，A 只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组。这就叫做**超时重传**。要实现超时重传，就要在每发送完一个分组设置一个超时计时器。如果在超时计时器到期之前收到了对方的确认，就撤销已设置的超时计时器，继续进入下一轮。

   <p>
      <img src="./images/base_yunshu_4.png" style="max-width: 60%;" class="medium-zoom-image"/>
   </p>

   确认丢失的情况下，即 A 在设定的超时重传时间内没有收到确认，但并无法知道是自己发送的分组出错、丢失，或者是 B 发送的确认丢失了。因此 A 在超时计时器到期后就要重传 M~1~。此时 B 又收到了重传的分组 M~1~，B 首先会丢弃这个重复的分组 M~1~，然后向 A 发送确认。

   确认迟到的情况下，即传输过程中没有出现差错，但 B 对分组 M~1~的确认迟到了。A 会收到重复的确认。对重复的确认的处理很简单：收下后就丢弃。B 仍然会收到重复的 M~1~，并且同样要丢弃重复的 M~1~，并重传确认分组。

   像上述的这种可靠传输协议常称为自动重传请求 ARQ (Automatic RepeatreQuest)。意思是重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组。

2. 连续 ARQ 协议

   滑动窗口

#### TCP 报文首部格式

TCP 虽然是面向字节流的，但 TCP 传送的数据单元却是报文段。一个 TCP 报文段分为首部和数据两部分，而 TCP 的全部功能都体现在它首部中各字段的作用。

<p>
   <img src="./images/base_yunshu_5.png" style="max-width: 80%;" class="medium-zoom-image"/>
</p>

1. **源端口和目的端口** 各占 2 个字节，分别写入源端口号和目的端口号。
2. **序号** 占 4 字节。序号范围是[0, 2^32^ - 1]，共 2^32^（即 4 294 967 296）个序号。序号增加到 2^32^ - 1 后，下一个序号就又回到 0。
3. **确认号** 占 4 字节，是期望收到对方下一个报文段的第一个数据字节的序号。若确认号 = N，则表明：到序号 N - 1 为止的所有数据都已正确收到。
4. **数据偏移** 占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。
5. **保留** 占 6 位，保留为今后使用，但目前应置为 0。
6. **紧急**URG (URGent) 当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)，而不要按原来的排队顺序来传送。
7. **确认**ACK (ACKnowlegment) 仅当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。
8. **推送** PSH (PuSH)当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。在这种情况下，TCP 就可以使用推送(push)操作。
9. **复位**RST (ReSeT)当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。
10. **同步**SYN (SYNchronization) 在连接建立时用来同步序号。当 SYN = 1 而 ACK= 0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 SYN = 1 和 ACK = 1。因此，SYN 置为 1 就表示这是一个连接请求或连接接受报文。
11. **终止**FIN (FINis，意思是“完”、“终”) 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。
12. **窗口** 占 2 字节。窗口值是[0, 2^16^ - 1]之间的整数。窗口字段明确指出了现在允许对方发送的数据量。窗口值是经常在动态变化着。
13. **检验和** 占 2 字节。检验和字段检验的范围包括首部和数据这两部分。
14. **紧急指针** 占 2 字节。紧急指针仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据）。
15. **选项** 长度可变，最长可达 40 字节。当没有使用“选项”时，TCP 的首部长度是 20 字节。

#### TCP 的连接建立

包括三个阶段，连接建立、数据传送和连接释放。

1. 连接建立

   三次握手建立 TCP 连接

   <p>
       <img src="./images/base_yunshu_6.png" style="max-width: 60%;" class="medium-zoom-image"/>
   </p>

   如上图所示，假定主机 A 运行的是 TCP 客户程序，而 B 运行 TCP 服务器程序。A 主动打开连接，而 B 被动打开连接。

   B 的 TCP 服务器进程先创建传输控制块 TCB，准备接受客户进程的连接请求。然后服务器进程就处于 LISTEN（收听）状态，等待客户的连接请求。

   :::tip
   传输控制块 TCB（Transmission Control Block）存储了每一个连接中的一些重要信息，如：TCP 连接表，到发送和接收缓存的指针，到重传队列的指针，当前的发送和接收序号，等等。
   :::

   A 的 TCP 客户进程也是首先创建传输控制模块 TCB，然后向 B 发出连接请求报文段，这时首部中的同步位 SYN = 1，同时选择一个初始序号 seq = x。TCP 规定，SYN 报文段（即 SYN = 1 的报文段）不能携带数据，但要消耗掉一个序号。这时，TCP 客户进程进入 SYN-SENT（同步已发送）状态。

   B 收到连接请求报文段后，如同意建立连接，则向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置 1，确认号是 ack = x +1，同时也为自己选择一个初始序号 seq = y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时 TCP 服务器进程进入 SYN-RCVD（同步收到）状态。

   TCP 客户进程收到 B 的确认后，还要向 B 给出确认。确认报文段的 ACK 置 1，确认号 ack = y + 1，而自己的序号 seq = x + 1。TCP 的标准规定，ACK 报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是 seq = x + 1。这时，TCP 连接已经建立，A 进入 ESTABLISHED（已建立连接）状态。

   当 B 收到 A 的确认后，也进入 ESTABLISHED 状态。

   :::warning
   为什么 A 还要发送一次确认呢？

   这主要是为了防止已失效的连接请求报文段突然又传送到了 B，因而产生错误。

   所谓“已失效的连接请求报文段”是这样产生的。考虑一种正常情况。A 发出连接请求，但因连接请求报文丢失而未收到确认。于是 A 再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A 共发送了两个连接请求报文段，其中第一个丢失，第二个到达了 B。没有“已失效的连接请求报文段”。

   现假定出现一种异常情况，即 A 发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达 B。本来这是一个早已失效的报文段。但 B 收到此失效的连接请求报文段后，就误认为是 A 又发出一次新的连接请求。于是就向 A 发出确认报文段，同意建立连接。假定不采用三次握手，那么只要 B 发出确认，新的连接就建立了。由于现在 A 并没有发出建立连接的请求，因此不会理睬 B 的确认，也不会向 B 发送数据。但 B 却以为新的运输连接已经建立了，并一直等待 A 发来数据。B 的许多资源就这样白白浪费了。

   采用三次握手的办法可以防止上述现象的发生。例如在刚才的情况下，A 不会向 B 的确认发出确认。B 由于收不到确认，就知道 A 并没有要求建立连接。
   :::

2. 连接释放

   四次握手释放 TCP 连接

   <p>
       <img src="./images/base_yunshu_7.png" style="max-width: 60%;" class="medium-zoom-image"/>
   </p>

   数据传输结束后，通信的双方都可释放连接。现在 A 和 B 都处于 ESTABLISHED 状态。A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的终止控制位 FIN 置 1，其序号 seq = u，它等于前面已传送过的数据的最后一个字节的序号加 1。这时 A 进入 FIN-WAIT-1（终止等待 1）状态，等待 B 的确认。请注意，TCP 规定，FIN 报文段即使不携带数据，它也消耗掉一个序号。

   B 收到连接释放报文段后即发出确认，确认号是 ack = u + 1，而这个报文段自己的序号是 v，等于 B 前面已传送过的数据的最后一个字节的序号加 1。然后 B 就进入 CLOSE-WAIT（关闭等待）状态。TCP 服务器进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的 TCP 连接处于半关闭(half-close)状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭，这个状态可能会持续一些时间。

   A 收到来自 B 的确认后，就进入 FIN-WAIT-2（终止等待 2）状态，等待 B 发出的连接释放报文段。

   若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使 FIN = 1。现假定 B 的序号为 w（在半关闭状态 B 可能又发送了一些数据）。B 还必须重复上次已发送过的确认号 ack = u + 1。这时 B 就进入 LAST-ACK（最后确认）状态，等待 A 的确认。

   A 在收到 B 的连接释放报文段后，必须对此发出确认。在确认报文段中把 ACK 置 1，确认号 ack = w + 1，而自己的序号是 seq =u + 1（根据 TCP 标准，前面发送过的 FIN 报文段要消耗一个序号）。然后进入到 TIME-WAIT（时间等待）状态。请注意，现在 TCP 连接还没有释放掉。必须经过时间等待计时器(TIME-WAIT timer)设置的时间 2MSL 后，A 才进入到 CLOSED 状态。时间 MSL 叫做最长报文段寿命(Maximum Segment Lifetime)，RFC 793 建议设为 2 分钟。但这完全是从工程上来考虑，对于现在的网络，MSL = 2 分钟可能太长了一些。因此 TCP 允许不同的实现可根据具体情况使用更小的 MSL 值。因此，从 A 进入到 TIME-WAIT 状态后，要经过 4 分钟才能进入到 CLOSED 状态，才能开始建立下一个新的连接。当 A 撤销相应的传输控制块 TCB 后，就结束了这次的 TCP 连接。

   B 只要收到了 A 发出的确认，就进入 CLOSED 状态。同样，B 在撤销相应的传输控制块 TCB 后，就结束了这次的 TCP 连接。我们注意到，B 结束 TCP 连接的时间要比 A 早一些。

   :::warning
   为什么 A 在 TIME-WAIT 状态必须等待 2MSL 的时间呢？这有两个理由。

   第一，为了保证 A 发送的最后一个 ACK 报文段能够到达 B。这个 ACK 报文段有可能丢失，因而使处在 LAST-ACK 状态的 B 收不到对已发送的 FIN + ACK 报文段的确认。B 会超时重传这个 FIN + ACK 报文段，而 A 就能在 2MSL 时间内收到这个重传的 FIN + ACK 报文段。接着 A 重传一次确认，重新启动 2MSL 计时器。最后，A 和 B 都正常进入到 CLOSED 状态。如果 A 在 TIME-WAIT 状态不等待一段时间，而是在发送完 ACK 报文段后立即释放连接，那么就无法收到 B 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段。这样，B 就无法按照正常步骤进入 CLOSED 状态。

   第二，防止上一节提到的“已失效的连接请求报文段”出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。
   :::

### 端口号

当运输层收到 IP 层交上来的运输层报文时，就能够根据其首部中的目的端口号把数据交付应用层的目的应用进程，剩下的工作（即最后交付目的进程）就由 TCP 来完成。

端口号为 16 位，所以一台计算机中可以允许有 2^16^ ，即 0 ~ 65535 的端口号。其中：

- 0 ~ 1023 为熟知端口号，一般指派给 TCP/IP 最重要的一些应用程序；
- 1024 ~ 49151 为登记端口号；
- 49152 ~ 65535 为短暂端口号，留给客户进程选择临时使用。

常见的熟知端口号：
| 应用程序 | 端口号 |
| :-----------: | :-----------: |
| FTP | 21 |
| TELNET | 23 |
| SMTP | 25 |
| DNS | 53 |
| TFTP | 69 |
| HTTP | 80 |
| SNMP | 161 |
| HTTPS | 443 |

## 应用层

运输层为应用提供了端到端的通信服务，不同的网络应用的`应用进程`之间的通信则需要应用层协议。

应用层协议包括以下常见类型：

- 域名系统 DNS 协议。
- FTP 文件传输协议。
- TELNET 远程终端协议
- HTTP（超文本传输协议），万维网的应用层协议。
- SMTP 电子邮件协议。
- POP3 邮件读取协议。
- ...

::: warning
应用层协议与网络应用并不是同一个概念。应用层协议只是网络应用的一部分。
:::

什么是应用？

以万维网为例，万维网浏览器、万维网服务器等都属于万维网应用。

### 域名系统 DNS

域名系统 DNS (Domain Name System)是因特网使用的命名系统，用来把便于人们使用的机器名字转换为 IP 地址。

用户与因特网上某个主机通信时，必须要知道对方的 IP 地址。然而用户很难记住长达 32 位二进制主机地址。即使是点分十进制 IP 地址也并不太容易记忆。但在应用层为了便于用户记忆各种网络应用，更多的是使用主机名字。比如我们访问必应网站时，只需要输入域名 <https://cn.bing.com/> 即可，而不是输入它的 IP 地址。

#### 域名结构

<p>
   <img src="./images/base_domain_1.png" style="max-width: 300px;" class="medium-zoom-image"/>
</p>

如图所示：域名以从右向左的顺序，依次为顶级域名、二级域名、三级域名、等等...

常见的顶级域名有：

- .com，公司企业
- .cn，中国
- .us，美国
- .net，网络服务机构
- .edu，教育机构
- ...

#### 域名服务器

DNS 服务器的管辖范围是以”区“为单位的，每一个区设置相应的权限域名服务器(authoritative name server)，用来保存该区中的所有主机的域名到 IP 地址的映射。区可能等于或小于域，但一定不可能大于域。

<p>
   <img src="./images/base_domain_2.png" style="max-width: 80%" class="medium-zoom-image"/>
</p>

1. 根域名服务器

   根域名服务器是最高层次的域名服务器，也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址。根域名服务器是最重要的域名服务器，因为不管是哪一个本地域名服务器，若要对因特网上任何一个域名进行解析（即转换为 IP 地址），只要自己无法解析，就首先要求助于根域名服务器。

   需要注意的是，在许多情况下，根域名服务器并不直接把待查询的域名直接转换成 IP 地址（根域名服务器也没有存放这种信息），而是告诉本地域名服务器下一步应当找哪一个顶级域名服务器进行查询。

2. 顶级域名服务器

   这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。当收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当找的域名服务器的 IP 地址）。

3. 权限域名服务器

   这就是前面已经讲过的负责一个区的域名服务器。当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器。

4. 本地域名服务器

   当一个主机发出 DNS 查询请求时，这个查询请求报文会先发送给本地域名服务器，也称为默认域名服务器。当所要查询的主机也属于同一个本地 ISP 时，该本地域名服务器立即就能将所查询的主机名转换为它的 IP 地址，而不需要再去询问其他的域名服务器。

**域名是如何解析的呢？**

首先了解两个概念：

1. 递归查询

   如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向其他根域名服务器继续发出查询请求报文（即替该主机继续查询），而不是让该主机自己进行下一步的查询。因此，递归查询返回的查询结果或者是所要查询的 IP 地址，或者是报错，表示无法查询到所需的 IP 地址。

2. 迭代查询

   当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询（而不是替本地域名服务器进行后续的查询）。

如下图所示：

<p>
   <img src="./images/base_domain_3.png" style="max-width: 80%" class="medium-zoom-image"/>
</p>

图中(a)的查询步骤：

1. 主机 m.xyz.com 先向其本地域名服务器 dns.xyz.com 进行递归查询。
2. 本地域名服务器采用迭代查询。它先向一个根域名服务器查询。
3. 根域名服务器告诉本地域名服务器，下一次应查询的顶级域名服务器 dns.com 的 IP 地址。
4. 本地域名服务器向顶级域名服务器 dns.com 进行查询。
5. 顶级域名服务器 dns.com 告诉本地域名服务器，下一次应查询的权限域名服务器 dns.abc.com 的 IP 地址。
6. 本地域名服务器向权限域名服务器 dns.abc.com 进行查询。
7. 权限域名服务器 dns.abc.com 告诉本地域名服务器，所查询的主机的 IP 地址。
8. 本地域名服务器最后把查询结果告诉主机 m.xyz.com。

::: warning

- 主机向本地域名服务器的查询一般都是采用递归查询。

- 本地域名服务器向根域名服务器的查询通常是采用迭代查询。当然，本地域名服务器也可以采用递归查询，这取决于最初的查询请求报文的设置是要求使用哪一种查询方式。

:::

### 超文本传输协议 HTTP

每个万维网网点都有一个服务器进程，它不断地监听 TCP 的端口 80，以便发现是否有浏览器向它发出连接建立请求。一旦监听到连接建立请求并建立了 TCP 连接之后，浏览器就向万维网服务器发出浏览某个页面的请求，服务器接着就返回所请求的页面作为响应。最后，TCP 连接就被释放了。在浏览器和服务器之间的请求和响应的交互，必须按照规定的格式和遵循一定的规则。这些格式和规则就是超文本传送协议 HTTP。

**当在浏览器中输入一个 URL 并发起请求时，都发生了什么呢？**

1. 浏览器分析链接指向页面的 URL（比如是：<https://www.baidu.com/>）。
2. 浏览器向 DNS 请求解析 www.baidu.com 的 IP 地址。
3. 域名系统 DNS 解析出对应服务器的 IP 地址。
4. 浏览器与服务器建立 TCP 连接。
5. 浏览器发出取文件命令。
6. 服务器给出响应，把文件 index.htm 发送给浏览器。
7. 释放 TCP 连接。
8. 浏览器显示百度页面内容。

#### HTTP 状态码

HTTP 状态码都是三位数字的，分为 5 大类。

- 1xx，表示通知信息的，如请求收到了或正在进行处理。
- 2xx，表示成功，如接受或知道了。
- 3xx，表示重定向，如要完成请求还必须采取进一步的行动。
- 4xx，表示客户端差错，如请求中有错误的语法或不能完成。
- 5xx，表示服务端差错，如服务器失效无法完成请求。

## 参考

- 《计算机网络》（第 6 版 谢希仁 ）
